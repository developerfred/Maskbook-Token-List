"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumAddress = void 0;
const keccak_1 = __importDefault(require("keccak"));
const util_1 = require("../util");
class EthereumAddress {
    constructor(publicKey) {
        this._publicKey = util_1.decompressPublicKey(publicKey);
    }
    static from(publicKey) {
        return new EthereumAddress(publicKey);
    }
    static checksumAddress(address) {
        if (!isValidFormat(address)) {
            throw new Error("invalid address");
        }
        const addr = util_1.strip0x(address).toLowerCase();
        const hash = keccak_1.default("keccak256")
            .update(addr, "ascii")
            .digest("hex");
        let newAddr = "0x";
        for (let i = 0; i < addr.length; i++) {
            if (hash[i] >= "8") {
                newAddr += addr[i].toUpperCase();
            }
            else {
                newAddr += addr[i];
            }
        }
        return newAddr;
    }
    static isValid(address) {
        if (!isValidFormat(address)) {
            return false;
        }
        const addr = util_1.strip0x(address);
        if (addr.match(/[0-9a-f]{40}/) || addr.match(/[0-9A-F]{40}/)) {
            return true;
        }
        let checksumAddress;
        try {
            checksumAddress = EthereumAddress.checksumAddress(addr);
        }
        catch (_err) {
            return false;
        }
        return addr === checksumAddress.slice(2);
    }
    get publicKey() {
        return this._publicKey;
    }
    get rawAddress() {
        if (!this._rawAddress) {
            this._rawAddress = keccak_1.default("keccak256")
                .update(this._publicKey.slice(1))
                .digest()
                .slice(-20);
        }
        return this._rawAddress;
    }
    get address() {
        if (!this._address) {
            const rawAddress = this.rawAddress.toString("hex");
            this._address = EthereumAddress.checksumAddress(rawAddress);
        }
        return this._address;
    }
}
exports.EthereumAddress = EthereumAddress;
function isValidFormat(address) {
    return !!util_1.strip0x(address).match(/^[0-9a-fA-F]{40}$/);
}
//# sourceMappingURL=index.js.map