"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = exports.Algorithm = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bs58 = __importStar(require("bs58"));
const crypto = __importStar(require("crypto"));
const elliptic_1 = require("elliptic");
const versions_1 = __importDefault(require("../versions"));
// Implements BIP-32: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
// Added ED25519 support: https://github.com/satoshilabs/slips/blob/master/slip-0010.md
var Algorithm;
(function (Algorithm) {
    Algorithm["secp256k1"] = "secp256k1";
    Algorithm["ed25519"] = "ed25519";
})(Algorithm = exports.Algorithm || (exports.Algorithm = {}));
const SUPPORTED_ALGORITHMS = [Algorithm.secp256k1, Algorithm.ed25519];
const HARDENED_KEY_OFFSET = 0x80000000; // 2^31
const secp256k1 = new elliptic_1.ec(Algorithm.secp256k1);
const ed25519 = new elliptic_1.eddsa(Algorithm.ed25519);
class HDKey {
    constructor({ algorithm, privateKey, publicKey, chainCode, index, depth, parentFingerprint, version, }) {
        this._privateKey = null;
        if (algorithm && SUPPORTED_ALGORITHMS.indexOf(algorithm) === -1) {
            throw new Error(`unsupported algorithm: ${algorithm}`);
        }
        this._algorithm = algorithm || Algorithm.secp256k1;
        if (!privateKey && !publicKey) {
            throw new Error("either private key or public key must be provided");
        }
        if (privateKey) {
            this._privateKey = privateKey;
            this._publicKey = publicFromPrivateKey(privateKey, this.algorithm);
        }
        else {
            this._publicKey = publicKey;
        }
        this._chainCode = chainCode;
        this._depth = depth || 0;
        this._index = index || 0;
        this._parentFingerprint = parentFingerprint || Buffer.alloc(4);
        this._keyIdentifier = hash160(this._publicKey);
        this._version = version || versions_1.default.bitcoinMain;
    }
    static parseMasterSeed(seed, version) {
        return this.parseSeedWithKey(Algorithm.secp256k1, "Bitcoin seed", seed, version);
    }
    static parseEd25519Seed(seed, version) {
        return this.parseSeedWithKey(Algorithm.ed25519, "ed25519 seed", seed, version);
    }
    static parseSeedWithKey(algorithm, key, seed, version) {
        const i = hmacSha512(key, seed);
        const iL = i.slice(0, 32);
        const iR = i.slice(32);
        return new HDKey({ algorithm, privateKey: iL, chainCode: iR, version });
    }
    static parseExtendedKey(key, version = versions_1.default.bitcoinMain) {
        // version_bytes[4] || depth[1] || parent_fingerprint[4] || index[4] ||
        // chain_code[32] || key_data[33] || checksum[4]
        const decoded = Buffer.from(bs58.decode(key));
        if (decoded.length > 112) {
            throw new Error("invalid extended key");
        }
        const checksum = decoded.slice(-4);
        const buf = decoded.slice(0, -4);
        if (!sha256(sha256(buf)).slice(0, 4).equals(checksum)) {
            throw new Error("invalid checksum");
        }
        let o = 0;
        const versionRead = buf.readUInt32BE(o);
        o += 4;
        const depth = buf.readUInt8(o);
        o += 1;
        let parentFingerprint = buf.slice(o, (o += 4));
        if (parentFingerprint.readUInt32BE(0) === 0) {
            parentFingerprint = undefined;
        }
        const index = buf.readUInt32BE(o);
        o += 4;
        const chainCode = buf.slice(o, (o += 32));
        const keyData = buf.slice(o);
        const privateKey = keyData[0] === 0 ? keyData.slice(1) : undefined;
        const publicKey = keyData[0] !== 0 ? keyData : undefined;
        if ((privateKey && versionRead !== version.bip32.private) ||
            (publicKey && versionRead !== version.bip32.public)) {
            throw new Error("invalid version bytes");
        }
        return new HDKey({
            privateKey,
            publicKey,
            chainCode,
            index,
            depth,
            parentFingerprint,
            version,
        });
    }
    get algorithm() {
        return this._algorithm;
    }
    get privateKey() {
        return this._privateKey || null;
    }
    get publicKey() {
        return this._publicKey;
    }
    get chainCode() {
        return this._chainCode;
    }
    get depth() {
        return this._depth;
    }
    get parentFingerprint() {
        return this._parentFingerprint;
    }
    get index() {
        return this._index;
    }
    get keyIdentifier() {
        return this._keyIdentifier;
    }
    get fingerprint() {
        return this._keyIdentifier.slice(0, 4);
    }
    get version() {
        return this._version;
    }
    get extendedPrivateKey() {
        if (this.algorithm === Algorithm.ed25519) {
            throw new Error("extended private key generation is not supported for ed25519");
        }
        return this._privateKey
            ? this.serialize(this._version.bip32.private, this._privateKey)
            : null;
    }
    get extendedPublicKey() {
        if (this.algorithm === Algorithm.ed25519) {
            throw new Error("extended public key generation is not supported for ed25519");
        }
        return this.serialize(this._version.bip32.public, this._publicKey);
    }
    derive(chain) {
        const c = chain.toLowerCase();
        let childKey = this;
        c.split("/").forEach((path) => {
            const p = path.trim();
            if (p === "m" || p === "m'" || p === "") {
                return;
            }
            const index = Number.parseInt(p, 10);
            if (Number.isNaN(index)) {
                throw new Error("invalid child key derivation chain");
            }
            const hardened = p.slice(-1) === "'";
            childKey = childKey.deriveChildKey(index, hardened);
        });
        return childKey;
    }
    deriveChildKey(childIndex, hardened) {
        if (childIndex >= HARDENED_KEY_OFFSET) {
            throw new Error("invalid index");
        }
        if (!this.privateKey && !this.publicKey) {
            throw new Error("either private key or public key must be provided");
        }
        let index = childIndex;
        const data = Buffer.alloc(37);
        let offset = 0; // offset
        if (hardened) {
            if (!this.privateKey) {
                throw new Error("cannot derive a hardened child key from a public key");
            }
            // 0x00 || ser256(kpar) || ser32(i)
            // 0x00[1] || parent_private_key[32] || child_index[4]
            index += HARDENED_KEY_OFFSET;
            offset += 1;
            offset += this.privateKey.copy(data, offset);
        }
        else {
            if (this.algorithm === Algorithm.ed25519) {
                throw new Error("non-hardened key generation is not supported for ed25519");
            }
            // serP(point(kpar)) || ser32(i)
            // compressed_parent_public_key[33] || child_index[4]
            offset += this.publicKey.copy(data, offset);
        }
        offset += data.writeUInt32BE(index, offset);
        const i = hmacSha512(this.chainCode, data);
        const iL = new bn_js_1.default(i.slice(0, 32));
        const iR = i.slice(32); // the returned chain code ci is IR
        // ed25519
        if (this.algorithm === Algorithm.ed25519) {
            if (!this.privateKey) {
                throw new Error("derivation from public parent key is not supported for ed25519");
            }
            // if curve is ed25519: The returned child key ki is parse256(IL)
            const childKey = iL;
            return new HDKey({
                algorithm: this.algorithm,
                privateKey: childKey.toArrayLike(Buffer, "be", 32),
                chainCode: iR,
                index,
                depth: this.depth + 1,
                parentFingerprint: this.fingerprint,
                version: this.version,
            });
        }
        // secp256k1
        // if parse256(IL) >= n, the resulting key is invalid; proceed with the next
        // value for i
        if (iL.cmp(secp256k1.n) >= 0) {
            return this.deriveChildKey(childIndex + 1, hardened);
        }
        if (this.privateKey) {
            // child key ki is parse256(IL) + kpar (mod n)
            const childKey = iL.add(new bn_js_1.default(this.privateKey)).mod(secp256k1.n);
            // if ki = 0, the resulting key is invalid; proceed with the next value
            // for i
            if (childKey.cmp(new bn_js_1.default(0)) === 0) {
                return this.deriveChildKey(childIndex + 1, hardened);
            }
            return new HDKey({
                algorithm: this.algorithm,
                privateKey: childKey.toArrayLike(Buffer, "be", 32),
                chainCode: iR,
                index,
                parentFingerprint: this.fingerprint,
                depth: this.depth + 1,
                version: this.version,
            });
        }
        else {
            // Ki is point(parse256(IL)) + Kpar = G * IL + Kpar
            const parentKey = secp256k1.keyFromPublic(this.publicKey).pub;
            const childKey = secp256k1.g.mul(iL).add(parentKey);
            // if Ki is the point at infinity, the resulting key is invalid; proceed
            // with the next value for i
            if (childKey.isInfinity()) {
                return this.deriveChildKey(childIndex + 1, false);
            }
            const compressedChildKey = Buffer.from(childKey.encode(null, true));
            return new HDKey({
                depth: this.depth + 1,
                publicKey: compressedChildKey,
                chainCode: iR,
                parentFingerprint: this.fingerprint,
                index,
                version: this.version,
            });
        }
    }
    serialize(version, key) {
        // version_bytes[4] || depth[1] || parent_fingerprint[4] || index[4] ||
        // chain_code[32] || key_data[33] || checksum[4]
        const buf = Buffer.alloc(78);
        let o = buf.writeUInt32BE(version, 0);
        o = buf.writeUInt8(this.depth, o);
        o += this.parentFingerprint.copy(buf, o);
        o = buf.writeUInt32BE(this.index, o);
        o += this.chainCode.copy(buf, o);
        o += 33 - key.length;
        key.copy(buf, o);
        const checksum = sha256(sha256(buf)).slice(0, 4);
        return bs58.encode(Buffer.concat([buf, checksum]));
    }
}
exports.HDKey = HDKey;
function hmacSha512(key, data) {
    return crypto.createHmac("sha512", key).update(data).digest();
}
function sha256(data) {
    return crypto.createHash("sha256").update(data).digest();
}
function hash160(data) {
    const d = crypto.createHash("sha256").update(data).digest();
    return crypto.createHash("rmd160").update(d).digest();
}
function publicFromPrivateKey(privateKey, algorithm) {
    let publicKey;
    switch (algorithm) {
        case Algorithm.secp256k1: {
            publicKey = secp256k1.keyFromPrivate(privateKey).getPublic(true, "hex");
            break;
        }
        case Algorithm.ed25519: {
            publicKey = "00" + ed25519.keyFromSecret(privateKey).getPublic("hex");
            break;
        }
        default:
            throw new Error("unsupported algorithm");
    }
    return Buffer.from(publicKey, "hex");
}
//# sourceMappingURL=index.js.map