"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const versions_1 = __importDefault(require("../versions"));
const bs58_1 = __importDefault(require("bs58"));
const crypto_1 = __importDefault(require("crypto"));
class BitcoinAddress {
    constructor({ publicKey, version, }) {
        const length = publicKey.length;
        const firstByte = publicKey[0];
        if ((length !== 33 && length !== 65) || firstByte < 2 || firstByte > 4) {
            throw new Error("invalid public key");
        }
        this._publicKey = publicKey;
        this._version = version || versions_1.default.bitcoinMain;
    }
    static from(publicKey, version) {
        return new BitcoinAddress({ publicKey, version });
    }
    static isValid(_address) {
        if (_address.length < 26 || _address.length > 35) {
            return false;
        }
        let rawAddress;
        try {
            rawAddress = Buffer.from(bs58_1.default.decode(_address));
        }
        catch (_err) {
            return false;
        }
        const checksumFromAddress = rawAddress.slice(-4);
        const checksum = sha256(sha256(rawAddress.slice(0, -4))).slice(0, 4);
        return checksum.equals(checksumFromAddress);
    }
    get publicKey() {
        return this._publicKey;
    }
    get rawAddress() {
        if (!this._rawAddress) {
            const hash = hash160(this._publicKey);
            const prefixedHash = Buffer.alloc(1 + hash.length);
            prefixedHash.writeUInt8(this._version.public, 0);
            hash.copy(prefixedHash, 1);
            const checksum = sha256(sha256(prefixedHash)).slice(0, 4);
            this._rawAddress = Buffer.concat([prefixedHash, checksum]);
        }
        return this._rawAddress;
    }
    get address() {
        if (!this._address) {
            this._address = bs58_1.default.encode(this.rawAddress);
        }
        return this._address;
    }
}
exports.default = BitcoinAddress;
function sha256(data) {
    return crypto_1.default.createHash("sha256").update(data).digest();
}
function hash160(data) {
    const d = crypto_1.default.createHash("sha256").update(data).digest();
    return crypto_1.default.createHash("rmd160").update(d).digest();
}
//# sourceMappingURL=index.js.map